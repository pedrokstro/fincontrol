[
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "3f76bb85-4ba1-40af-b3cd-9369f56c5c33",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC001-authentication system endpoints",
    "description": "test all authentication related endpoints including login, registration, email verification, password reset, and jwt token management to ensure secure and reliable user authentication flows.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5000\"\nUSERNAME = \"pedrocastro767@gmail.com\"\nPASSWORD = \"qActive4@#\"\nTIMEOUT = 30\n\ndef test_authentication_system_endpoints():\n    \"\"\"\n    Test all authentication related endpoints including:\n    - Registration\n    - Email verification\n    - Login\n    - Password reset flow\n    - JWT token management\n    Ensuring secure and reliable user authentication flows.\n    \"\"\"\n    session = requests.Session()\n    session.auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n\n    user_data = {\n        \"email\": \"testuser+pythontest@example.com\",\n        \"password\": \"StrongPassw0rd!@#\",\n        \"full_name\": \"Python Test User\"\n    }\n\n    user_id = None\n\n    # 1. Register a new user\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    try:\n        register_resp = session.post(register_url, json=user_data, headers=headers, timeout=TIMEOUT)\n        assert register_resp.status_code in (200, 201), f\"Registration failed: {register_resp.text}\"\n        reg_json = register_resp.json()\n        assert \"userId\" in reg_json or \"id\" in reg_json, \"User ID not returned on registration\"\n\n        user_id = reg_json.get(\"userId\") or reg_json.get(\"id\")\n\n        # 2. Simulate email verification - generally requires a token from email\n        # Assuming API endpoint to verify email via token, we mock this by requesting the verification token endpoint\n        verify_email_url = f\"{BASE_URL}/api/auth/verify-email\"\n        # Normally token comes from email; here trying to request token for testing purpose\n        request_token_resp = session.post(f\"{BASE_URL}/api/auth/request-email-verification\", json={\"email\": user_data[\"email\"]}, headers=headers, timeout=TIMEOUT)\n        assert request_token_resp.status_code == 200, f\"Email verification token request failed: {request_token_resp.text}\"\n        token_json = request_token_resp.json()\n        assert \"verificationToken\" in token_json, \"Verification token not received\"\n        verification_token = token_json[\"verificationToken\"]\n\n        verify_resp = session.post(verify_email_url, json={\"token\": verification_token}, headers=headers, timeout=TIMEOUT)\n        assert verify_resp.status_code == 200, f\"Email verification failed: {verify_resp.text}\"\n\n        # 3. Login with the newly registered user\n        login_url = f\"{BASE_URL}/api/auth/login\"\n        login_payload = {\n            \"email\": user_data[\"email\"],\n            \"password\": user_data[\"password\"]\n        }\n        login_resp = session.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_json = login_resp.json()\n        assert \"accessToken\" in login_json, \"Access token missing in login response\"\n        assert \"refreshToken\" in login_json, \"Refresh token missing in login response\"\n\n        access_token = login_json[\"accessToken\"]\n        refresh_token = login_json[\"refreshToken\"]\n        auth_headers = headers.copy()\n        auth_headers[\"Authorization\"] = f\"Bearer {access_token}\"\n\n        # 4. Validate JWT token by accessing a protected endpoint (assuming /api/auth/profile)\n        profile_url = f\"{BASE_URL}/api/auth/profile\"\n        profile_resp = session.get(profile_url, headers=auth_headers, timeout=TIMEOUT)\n        assert profile_resp.status_code == 200, f\"Accessing protected profile endpoint failed: {profile_resp.text}\"\n        profile_data = profile_resp.json()\n        assert profile_data.get(\"email\") == user_data[\"email\"], \"Profile email does not match logged in user\"\n\n        # 5. Refresh JWT token using refresh token endpoint\n        refresh_url = f\"{BASE_URL}/api/auth/token/refresh\"\n        refresh_resp = session.post(refresh_url, json={\"refreshToken\": refresh_token}, headers=headers, timeout=TIMEOUT)\n        assert refresh_resp.status_code == 200, f\"Token refresh failed: {refresh_resp.text}\"\n        refresh_json = refresh_resp.json()\n        assert \"accessToken\" in refresh_json, \"New access token missing after refresh\"\n\n        new_access_token = refresh_json[\"accessToken\"]\n\n        # 6. Password reset flow\n        # 6a. Request password reset token\n        forgot_password_url = f\"{BASE_URL}/api/auth/forgot-password\"\n        forgot_resp = session.post(forgot_password_url, json={\"email\": user_data[\"email\"]}, headers=headers, timeout=TIMEOUT)\n        assert forgot_resp.status_code == 200, f\"Forgot password request failed: {forgot_resp.text}\"\n        forgot_json = forgot_resp.json()\n        assert \"resetToken\" in forgot_json, \"Reset token missing in forgot password response\"\n        reset_token = forgot_json[\"resetToken\"]\n\n        # 6b. Reset password with token\n        new_password = \"NewStrongPassw0rd!@#\"\n        reset_password_url = f\"{BASE_URL}/api/auth/reset-password\"\n        reset_payload = {\n            \"token\": reset_token,\n            \"newPassword\": new_password\n        }\n        reset_resp = session.post(reset_password_url, json=reset_payload, headers=headers, timeout=TIMEOUT)\n        assert reset_resp.status_code == 200, f\"Password reset failed: {reset_resp.text}\"\n\n        # 6c. Login with new password\n        login_new_payload = {\n            \"email\": user_data[\"email\"],\n            \"password\": new_password\n        }\n        login_new_resp = session.post(login_url, json=login_new_payload, headers=headers, timeout=TIMEOUT)\n        assert login_new_resp.status_code == 200, f\"Login with new password failed: {login_new_resp.text}\"\n        login_new_json = login_new_resp.json()\n        assert \"accessToken\" in login_new_json, \"Access token missing after login with new password\"\n\n    finally:\n        # Clean up - delete created user if possible (needs auth token or basic auth)\n        if user_id is not None:\n            delete_user_url = f\"{BASE_URL}/api/auth/users/{user_id}\"\n            try:\n                # Attempt delete with basic auth for cleanup\n                del_resp = session.delete(delete_user_url, headers=headers, timeout=TIMEOUT)\n                # Allow either 200 or 204 as success\n                assert del_resp.status_code in (200, 204, 404), f\"User deletion failed: {del_resp.status_code} {del_resp.text}\"\n            except Exception:\n                # Ignore errors during cleanup\n                pass\n\ntest_authentication_system_endpoints()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 132, in <module>\n  File \"<string>\", line 38, in test_authentication_system_endpoints\nAssertionError: Registration failed: {\"success\":false,\"message\":\"Rota /api/auth/register n達o encontrada\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.627Z",
    "modified": "2025-11-19T12:43:37.678Z"
  },
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "bcaaaeed-9eb7-4f9d-95b7-f814ee3ece7d",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC002-dashboard data retrieval",
    "description": "verify the dashboard api endpoint returns correct financial overview data, charts data, recent transactions, and quick actions with proper performance.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport time\n\ndef test_dashboard_data_retrieval():\n    base_url = \"http://localhost:5000\"\n    endpoint = f\"{base_url}/api/dashboard\"\n    auth = HTTPBasicAuth(\"pedrocastro767@gmail.com\", \"qActive4@#\")\n    headers = {\n        \"Accept\": \"application/json\",\n    }\n    timeout = 30\n\n    start_time = time.time()\n    try:\n        response = requests.get(endpoint, auth=auth, headers=headers, timeout=timeout)\n    except requests.RequestException as e:\n        assert False, f\"Request to dashboard endpoint failed: {e}\"\n\n    elapsed_time = time.time() - start_time\n\n    # Assert on response status\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    \n    # Validate response JSON structure and content\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate presence of main dashboard keys\n    expected_keys = [\"financialOverview\", \"chartsData\", \"recentTransactions\", \"quickActions\"]\n    for key in expected_keys:\n        assert key in data, f\"Key '{key}' missing in dashboard response\"\n\n    # Validate financial overview content (basic checks)\n    financial_overview = data[\"financialOverview\"]\n    assert isinstance(financial_overview, dict), \"'financialOverview' should be a dictionary\"\n    # Example checks for balance, income, expense fields presence\n    for field in [\"balance\", \"totalIncome\", \"totalExpense\"]:\n        assert field in financial_overview, f\"'{field}' missing in financialOverview\"\n        assert isinstance(financial_overview[field], (int, float)), f\"'{field}' should be numeric\"\n\n    # Validate chartsData - expecting dict or list (depends on implementation)\n    charts_data = data[\"chartsData\"]\n    assert charts_data is not None, \"'chartsData' should not be None\"\n\n    # Validate recentTransactions - expecting list, allow empty but ensure type\n    recent_transactions = data[\"recentTransactions\"]\n    assert isinstance(recent_transactions, list), \"'recentTransactions' should be a list\"\n    # If there are transactions, check the first item for expected keys\n    if recent_transactions:\n        sample_tx = recent_transactions[0]\n        assert isinstance(sample_tx, dict), \"Each item in 'recentTransactions' should be a dict\"\n        tx_expected_keys = [\"id\", \"date\", \"category\", \"amount\", \"type\", \"description\"]\n        for key in tx_expected_keys:\n            assert key in sample_tx, f\"Transaction item missing key '{key}'\"\n\n    # Validate quickActions - expecting list or dict (check at least existence)\n    quick_actions = data[\"quickActions\"]\n    assert quick_actions is not None, \"'quickActions' should not be None\"\n\n    # Validate performance: response time should be reasonable (under 3 seconds)\n    assert elapsed_time <= 3, f\"Dashboard API response time too high: {elapsed_time:.2f}s\"\n\ntest_dashboard_data_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 66, in <module>\n  File \"<string>\", line 23, in test_dashboard_data_retrieval\nAssertionError: Expected status code 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.638Z",
    "modified": "2025-11-19T12:42:59.008Z"
  },
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "3a303e3e-ae13-4fdf-87c5-dee72f154f99",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC003-transaction management endpoints",
    "description": "test create, read, update, and delete transaction endpoints with validation, filtering, and pagination to ensure correct transaction management and performance.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5000\"\nAUTH = HTTPBasicAuth('pedrocastro767@gmail.com', 'qActive4@#')\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_transaction_management_endpoints():\n    transaction_id = None\n    try:\n        # 1. Create a transaction\n        create_payload = {\n            \"amount\": 150.75,\n            \"date\": \"2025-11-14T10:30:00Z\",\n            \"description\": \"Test transaction creation\",\n            \"category\": \"Groceries\",\n            \"type\": \"expense\"  # assuming \"type\" is required: expense or income\n        }\n        create_resp = requests.post(\n            f\"{BASE_URL}/transactions\",\n            json=create_payload,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Create transaction failed: {create_resp.text}\"\n        created_data = create_resp.json()\n        assert \"id\" in created_data, \"Created transaction has no id\"\n        transaction_id = created_data[\"id\"]\n        assert created_data[\"amount\"] == create_payload[\"amount\"]\n        assert created_data[\"description\"] == create_payload[\"description\"]\n        assert created_data[\"category\"] == create_payload[\"category\"]\n        assert created_data[\"type\"] == create_payload[\"type\"]\n\n        # 2. Read transaction by ID\n        read_resp = requests.get(\n            f\"{BASE_URL}/transactions/{transaction_id}\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert read_resp.status_code == 200, f\"Read transaction failed: {read_resp.text}\"\n        read_data = read_resp.json()\n        assert read_data[\"id\"] == transaction_id\n        assert read_data[\"amount\"] == create_payload[\"amount\"]\n\n        # 3. Update the transaction\n        update_payload = {\n            \"amount\": 200.00,\n            \"description\": \"Updated transaction description\",\n            \"category\": \"Health\",\n            \"type\": \"expense\"\n        }\n        update_resp = requests.put(\n            f\"{BASE_URL}/transactions/{transaction_id}\",\n            json=update_payload,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert update_resp.status_code == 200, f\"Update transaction failed: {update_resp.text}\"\n        updated_data = update_resp.json()\n        assert updated_data[\"amount\"] == update_payload[\"amount\"]\n        assert updated_data[\"description\"] == update_payload[\"description\"]\n        assert updated_data[\"category\"] == update_payload[\"category\"]\n\n        # 4. Test filtering transactions - e.g. filter by category \"Health\"\n        filter_params = {\n            \"category\": \"Health\",\n            \"page\": 1,\n            \"page_size\": 5\n        }\n        filter_resp = requests.get(\n            f\"{BASE_URL}/transactions\",\n            params=filter_params,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert filter_resp.status_code == 200, f\"Filter transactions failed: {filter_resp.text}\"\n        filter_data = filter_resp.json()\n        assert \"transactions\" in filter_data, \"Filter response missing 'transactions'\"\n        assert isinstance(filter_data[\"transactions\"], list), \"'transactions' should be a list\"\n        # Check that returned transactions match the filter parameter category\n        for tr in filter_data[\"transactions\"]:\n            assert tr[\"category\"] == \"Health\"\n\n        # 5. Test pagination in listing transactions\n        pagination_params = {\n            \"page\": 1,\n            \"page_size\": 2\n        }\n        page1_resp = requests.get(\n            f\"{BASE_URL}/transactions\",\n            params=pagination_params,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert page1_resp.status_code == 200, f\"Pagination page 1 failed: {page1_resp.text}\"\n        page1_data = page1_resp.json()\n        assert \"transactions\" in page1_data\n        assert len(page1_data[\"transactions\"]) <= 2\n\n        pagination_params[\"page\"] = 2\n        page2_resp = requests.get(\n            f\"{BASE_URL}/transactions\",\n            params=pagination_params,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert page2_resp.status_code == 200, f\"Pagination page 2 failed: {page2_resp.text}\"\n        page2_data = page2_resp.json()\n        assert \"transactions\" in page2_data\n\n        # Validate that page1 and page2 transactions are not overlapping by IDs if both have data\n        if page1_data[\"transactions\"] and page2_data[\"transactions\"]:\n            ids_page1 = set(t[\"id\"] for t in page1_data[\"transactions\"])\n            ids_page2 = set(t[\"id\"] for t in page2_data[\"transactions\"])\n            assert ids_page1.isdisjoint(ids_page2)\n\n        # 6. Delete the transaction\n        delete_resp = requests.delete(\n            f\"{BASE_URL}/transactions/{transaction_id}\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert delete_resp.status_code == 204, f\"Delete transaction failed: {delete_resp.text}\"\n\n        # 7. Verify deletion: fetching again should return 404\n        get_after_delete_resp = requests.get(\n            f\"{BASE_URL}/transactions/{transaction_id}\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_after_delete_resp.status_code == 404\n\n        transaction_id = None  # Mark as deleted so no cleanup in finally\n\n    finally:\n        # Cleanup in case test fails before deletion\n        if transaction_id is not None:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/transactions/{transaction_id}\",\n                    auth=AUTH,\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\ntest_transaction_management_endpoints()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 157, in <module>\n  File \"<string>\", line 27, in test_transaction_management_endpoints\nAssertionError: Create transaction failed: {\"success\":false,\"message\":\"Rota /transactions n達o encontrada\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.643Z",
    "modified": "2025-11-19T12:42:59.865Z"
  },
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "5eb225e0-501d-4cd8-ab49-f27b5e4b73d4",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC004-category management endpoints",
    "description": "verify endpoints for managing income and expense categories including creation, update, deletion, and retrieval with custom icons, emojis, and colors.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5000\"\nAUTH = HTTPBasicAuth(\"pedrocastro767@gmail.com\", \"qActive4@#\")\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef test_category_management_endpoints():\n    category_id = None\n    try:\n        # 1. Create a new category (income or expense) with custom icon, emoji, and color\n        create_payload = {\n            \"name\": \"Test Category\",\n            \"type\": \"income\",  # or \"expense\"\n            \"icon\": \"wallet\",\n            \"emoji\": \"\u001f4b0\",\n            \"color\": \"#00FF00\"\n        }\n        response = requests.post(\n            f\"{BASE_URL}/category\",\n            json=create_payload,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 201, f\"Create failed: {response.text}\"\n        category = response.json()\n        category_id = category.get(\"id\")\n        assert category_id is not None, \"No category id returned on create\"\n        assert category.get(\"name\") == create_payload[\"name\"]\n        assert category.get(\"type\") == create_payload[\"type\"]\n        assert category.get(\"icon\") == create_payload[\"icon\"]\n        assert category.get(\"emoji\") == create_payload[\"emoji\"]\n        assert category.get(\"color\") == create_payload[\"color\"]\n\n        # 2. Retrieve the created category by ID\n        response = requests.get(\n            f\"{BASE_URL}/category/{category_id}\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 200, f\"Get by ID failed: {response.text}\"\n        gotten_category = response.json()\n        assert gotten_category[\"id\"] == category_id\n        assert gotten_category[\"name\"] == create_payload[\"name\"]\n        assert gotten_category[\"emoji\"] == create_payload[\"emoji\"]\n\n        # 3. Update the category's name, icon, emoji, and color\n        update_payload = {\n            \"name\": \"Updated Category\",\n            \"icon\": \"piggy-bank\",\n            \"emoji\": \"\u001f437\",\n            \"color\": \"#FF5733\"\n        }\n        response = requests.put(\n            f\"{BASE_URL}/category/{category_id}\",\n            json=update_payload,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 200, f\"Update failed: {response.text}\"\n        updated_category = response.json()\n        assert updated_category[\"id\"] == category_id\n        assert updated_category[\"name\"] == update_payload[\"name\"]\n        assert updated_category[\"icon\"] == update_payload[\"icon\"]\n        assert updated_category[\"emoji\"] == update_payload[\"emoji\"]\n        assert updated_category[\"color\"] == update_payload[\"color\"]\n\n        # 4. Retrieve list of all categories and verify the updated category is present\n        response = requests.get(\n            f\"{BASE_URL}/category\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 200, f\"Get list failed: {response.text}\"\n        categories = response.json()\n        assert isinstance(categories, list)\n        match = next((c for c in categories if c[\"id\"] == category_id), None)\n        assert match is not None, \"Updated category not found in list\"\n        assert match[\"name\"] == update_payload[\"name\"]\n        assert match[\"icon\"] == update_payload[\"icon\"]\n\n        # 5. Delete the category\n        response = requests.delete(\n            f\"{BASE_URL}/category/{category_id}\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code in (200, 204), f\"Delete failed: {response.text}\"\n\n        # 6. Verify that the category no longer exists\n        response = requests.get(\n            f\"{BASE_URL}/category/{category_id}\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 404, \"Deleted category still accessible\"\n\n    finally:\n        # Cleanup in case test failed before deletion\n        if category_id is not None:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/category/{category_id}\",\n                    auth=AUTH,\n                    headers=HEADERS,\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n\n\ntest_category_management_endpoints()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 120, in <module>\n  File \"<string>\", line 28, in test_category_management_endpoints\nAssertionError: Create failed: {\"success\":false,\"message\":\"Rota /category n達o encontrada\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.649Z",
    "modified": "2025-11-19T12:43:29.646Z"
  },
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "c1f6775b-d4cc-4041-aedb-d9bd7b75eaff",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC005-financial reports generation",
    "description": "test financial reports api endpoints to ensure accurate data aggregation, chart data generation, and export functionality in multiple formats.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5000\"\nUSERNAME = \"pedrocastro767@gmail.com\"\nPASSWORD = \"qActive4@#\"\nTIMEOUT = 30\n\ndef test_financial_reports_generation():\n    auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    headers = {\"Accept\": \"application/json\"}\n\n    # 1. Test chart data generation endpoint\n    chart_url = f\"{BASE_URL}/api/reports/chart\"\n    try:\n        resp_chart = requests.get(chart_url, auth=auth, headers=headers, timeout=TIMEOUT)\n        assert resp_chart.status_code == 200, f\"Chart endpoint status {resp_chart.status_code}\"\n        chart_data = resp_chart.json()\n        assert isinstance(chart_data, dict), \"Chart response is not a dict\"\n        # Validate presence of expected chart types and data format\n        for chart_type in (\"income_trends\", \"expense_trends\", \"category_breakdown\"):\n            assert chart_type in chart_data, f\"Missing chart type '{chart_type}' in chart data\"\n            assert isinstance(chart_data[chart_type], list), f\"Chart data for '{chart_type}' not a list\"\n            # Each item in the list should be a dict with at least 'label' and 'value'\n            for item in chart_data[chart_type]:\n                assert isinstance(item, dict), f\"Chart item in '{chart_type}' not a dict\"\n                assert \"label\" in item and \"value\" in item, f\"Chart item in '{chart_type}' missing 'label' or 'value'\"\n    except requests.RequestException as e:\n        assert False, f\"Chart request failed: {e}\"\n\n    # 2. Test export functionality for multiple formats\n    export_formats = [\"json\", \"csv\", \"excel\", \"pdf\"]\n    export_url = f\"{BASE_URL}/api/reports/export\"\n    for fmt in export_formats:\n        params = {\"format\": fmt}\n        try:\n            resp_export = requests.get(export_url, auth=auth, headers=headers, params=params, timeout=TIMEOUT)\n            assert resp_export.status_code == 200, f\"Export {fmt} endpoint status {resp_export.status_code}\"\n            content_type = resp_export.headers.get(\"Content-Type\", \"\")\n            # Validate content type by format\n            if fmt == \"json\":\n                assert \"application/json\" in content_type, f\"Unexpected content-type for json export: {content_type}\"\n                data = resp_export.json()  # Should parse without error\n                assert isinstance(data, list) or isinstance(data, dict), \"Exported JSON data structure unexpected\"\n            elif fmt == \"csv\":\n                assert \"text/csv\" in content_type or \"application/csv\" in content_type, f\"Unexpected content-type for csv: {content_type}\"\n                assert resp_export.text.startswith((\"Date\", \"date\", \"Transaction\", \"transaction\")), \"CSV export content likely invalid\"\n            elif fmt == \"excel\":\n                assert \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" in content_type or \\\n                       \"application/vnd.ms-excel\" in content_type, f\"Unexpected content-type for excel: {content_type}\"\n                assert len(resp_export.content) > 0, \"Excel export file is empty\"\n            elif fmt == \"pdf\":\n                assert \"application/pdf\" in content_type, f\"Unexpected content-type for pdf: {content_type}\"\n                assert len(resp_export.content) > 0, \"PDF export file is empty\"\n        except requests.RequestException as e:\n            assert False, f\"Export {fmt} request failed: {e}\"\n\ntest_financial_reports_generation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 17, in test_financial_reports_generation\nAssertionError: Chart endpoint status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.654Z",
    "modified": "2025-11-19T12:43:32.616Z"
  },
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "8da6f05c-eb02-49e0-9876-8faafe6a8341",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC006-savings goal management",
    "description": "verify endpoints for creating, updating, tracking progress, and deleting savings goals with correct deadline management and progress calculation.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport datetime\n\nBASE_URL = \"http://localhost:5000\"\nAUTH = HTTPBasicAuth(\"pedrocastro767@gmail.com\", \"qActive4@#\")\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\n\ndef test_savings_goal_management():\n    goal_id = None\n    try:\n        # Create a new savings goal\n        create_payload = {\n            \"name\": \"Test Goal\",\n            \"target_amount\": 1000.0,\n            \"current_amount\": 100.0,\n            \"deadline\": (datetime.datetime.now() + datetime.timedelta(days=60)).strftime(\"%Y-%m-%d\")\n        }\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/savings-goals\",\n            json=create_payload,\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Unexpected status code on creation: {create_resp.status_code}\"\n        create_data = create_resp.json()\n        assert \"id\" in create_data, \"Response JSON missing 'id' after creation\"\n        goal_id = create_data[\"id\"]\n        assert create_data[\"name\"] == create_payload[\"name\"]\n        assert abs(create_data[\"target_amount\"] - create_payload[\"target_amount\"]) < 0.001\n        assert abs(create_data[\"current_amount\"] - create_payload[\"current_amount\"]) < 0.001\n        assert create_data[\"deadline\"] == create_payload[\"deadline\"]\n\n        # Update the savings goal: increase current_amount and change deadline\n        new_current_amount = 300.0\n        new_deadline_date = (datetime.datetime.now() + datetime.timedelta(days=90)).strftime(\"%Y-%m-%d\")\n        update_payload = {\n            \"name\": \"Test Goal Updated\",\n            \"target_amount\": 1500.0,\n            \"current_amount\": new_current_amount,\n            \"deadline\": new_deadline_date\n        }\n        update_resp = requests.put(\n            f\"{BASE_URL}/api/savings-goals/{goal_id}\",\n            json=update_payload,\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert update_resp.status_code == 200, f\"Unexpected status code on update: {update_resp.status_code}\"\n        update_data = update_resp.json()\n        assert update_data[\"name\"] == update_payload[\"name\"]\n        assert abs(update_data[\"target_amount\"] - update_payload[\"target_amount\"]) < 0.001\n        assert abs(update_data[\"current_amount\"] - update_payload[\"current_amount\"]) < 0.001\n        assert update_data[\"deadline\"] == update_payload[\"deadline\"]\n\n        # Retrieve the savings goal to verify progress and deadline\n        get_resp = requests.get(\n            f\"{BASE_URL}/api/savings-goals/{goal_id}\",\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"Unexpected status code on retrieve: {get_resp.status_code}\"\n        goal_data = get_resp.json()\n\n        # Validate progress calculation: progress = current_amount / target_amount\n        target_amt = goal_data.get(\"target_amount\")\n        current_amt = goal_data.get(\"current_amount\")\n        assert target_amt and target_amt > 0, \"Invalid target_amount for savings goal\"\n        expected_progress = current_amt / target_amt\n        progress_reported = goal_data.get(\"progress\")\n        assert progress_reported is not None, \"Progress field missing in response\"\n        # Allow small float precision difference\n        assert abs(progress_reported - expected_progress) < 0.001, f\"Progress calculation incorrect: expected {expected_progress}, got {progress_reported}\"\n\n        # Validate deadline is a valid date string and matches updated deadline\n        deadline_str = goal_data.get(\"deadline\")\n        assert deadline_str == new_deadline_date, f\"Deadline mismatch: expected {new_deadline_date}, got {deadline_str}\"\n\n        # Delete the savings goal\n        delete_resp = requests.delete(\n            f\"{BASE_URL}/api/savings-goals/{goal_id}\",\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert delete_resp.status_code == 204, f\"Unexpected status code on delete: {delete_resp.status_code}\"\n\n        # Verify deletion by attempting to GET - should return 404 or similar\n        get_after_delete_resp = requests.get(\n            f\"{BASE_URL}/api/savings-goals/{goal_id}\",\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert get_after_delete_resp.status_code == 404, f\"Savings goal was not deleted properly, status code: {get_after_delete_resp.status_code}\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    finally:\n        # Cleanup if test failed before deletion\n        if goal_id is not None:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/savings-goals/{goal_id}\",\n                    headers=HEADERS,\n                    auth=AUTH,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\n\ntest_savings_goal_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 119, in <module>\n  File \"<string>\", line 28, in test_savings_goal_management\nAssertionError: Unexpected status code on creation: 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.659Z",
    "modified": "2025-11-19T12:43:50.920Z"
  },
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "6b3db0cd-2f39-4587-a509-41319e0d5f26",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC007-user settings management",
    "description": "test user settings endpoints for profile updates, theme preferences, notification settings, and account security changes to ensure persistent and correct updates.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5000\"\nAUTH = HTTPBasicAuth(\"pedrocastro767@gmail.com\", \"qActive4@#\")\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_user_settings_management():\n    # 1. Get current user profile\n    profile_url = f\"{BASE_URL}/user/profile\"\n    theme_url = f\"{BASE_URL}/user/theme\"\n    security_url = f\"{BASE_URL}/user/security\"\n\n    try:\n        # Fetch current profile\n        r = requests.get(profile_url, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200\n        profile_before = r.json()\n        assert \"email\" in profile_before and isinstance(profile_before[\"email\"], str)\n        assert \"name\" in profile_before and isinstance(profile_before[\"name\"], str)\n\n        # Update user profile - only update 'name' as per PRD\n        updated_profile_data = {\n            \"name\": \"Pedro Castro Updated\"\n        }\n        r = requests.put(profile_url, json=updated_profile_data, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200\n        updated_profile = r.json()\n        assert updated_profile.get(\"name\") == updated_profile_data[\"name\"]\n\n        # Verify profile update persisted\n        r = requests.get(profile_url, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200\n        profile_after = r.json()\n        assert profile_after.get(\"name\") == updated_profile_data[\"name\"]\n\n        # Update theme preference (assume theme can be 'light' or 'dark')\n        current_theme = profile_after.get(\"theme\", \"light\")\n        new_theme = \"dark\" if current_theme == \"light\" else \"light\"\n        r = requests.put(theme_url, json={\"theme\": new_theme}, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200\n        theme_response = r.json()\n        assert theme_response.get(\"theme\") == new_theme\n\n        # Verify theme preference persisted\n        r = requests.get(theme_url, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200\n        theme_after = r.json()\n        assert theme_after.get(\"theme\") == new_theme\n\n        # Change account security settings - change password\n        new_password = \"NewP@ssword123!\"\n        security_change_payload = {\n            \"current_password\": \"qActive4@#\",\n            \"new_password\": new_password,\n            \"confirm_new_password\": new_password\n        }\n        r = requests.put(security_url, json=security_change_payload, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200\n        security_response = r.json()\n        assert security_response.get(\"message\") and \"success\" in security_response.get(\"message\").lower()\n\n        # Revert password change\n        security_revert_payload = {\n            \"current_password\": new_password,\n            \"new_password\": \"qActive4@#\",\n            \"confirm_new_password\": \"qActive4@#\"\n        }\n        r = requests.put(security_url, json=security_revert_payload, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200\n        revert_response = r.json()\n        assert revert_response.get(\"message\") and \"success\" in revert_response.get(\"message\").lower()\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n    except AssertionError as e:\n        raise\n\ntest_user_settings_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 18, in test_user_settings_management\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.664Z",
    "modified": "2025-11-19T12:43:44.625Z"
  },
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "e25f0a0c-69e0-4407-966c-a469d4243843",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC008-data export functionality",
    "description": "verify data export endpoints produce correctly formatted files in json, csv, excel, and pdf formats with applied filters.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5000\"\nUSERNAME = \"pedrocastro767@gmail.com\"\nPASSWORD = \"qActive4@#\"\nTIMEOUT = 30\n\ndef test_data_export_functionality():\n    auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    export_formats = [\"json\", \"csv\", \"excel\", \"pdf\"]\n    export_endpoint = f\"{BASE_URL}/api/export\"\n\n    # Define a sample filter payload with only supported fields\n    filters = {\n        \"dateRange\": {\"start\": \"2024-01-01\", \"end\": \"2024-12-31\"}\n    }\n\n    for fmt in export_formats:\n        try:\n            params = {\"format\": fmt}\n            payload = {\"filters\": filters}\n            response = requests.post(\n                export_endpoint,\n                auth=auth,\n                json=payload,\n                params=params,\n                timeout=TIMEOUT\n            )\n            assert response.status_code == 200, f\"Failed format {fmt}: HTTP {response.status_code}\"\n\n            content_type = response.headers.get(\"Content-Type\", \"\")\n            content = response.content\n            # Validate content type and content format per export type\n            if fmt == \"json\":\n                assert \"application/json\" in content_type.lower(), f\"Expected json content-type for {fmt}, got {content_type}\"\n                data = response.json()\n                assert isinstance(data, (list, dict)), f\"JSON export did not return list or dict for {fmt}\"\n            elif fmt == \"csv\":\n                assert \"text/csv\" in content_type.lower() or \"application/csv\" in content_type.lower(), f\"Expected csv content-type for {fmt}, got {content_type}\"\n                text = content.decode('utf-8')\n                assert \",\" in text.splitlines()[0], f\"CSV export does not contain expected delimiter for {fmt}\"\n            elif fmt == \"excel\":\n                # Excel file content-type common values\n                assert (\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" in content_type.lower()\n                        or \"application/vnd.ms-excel\" in content_type.lower()), f\"Expected excel content-type for {fmt}, got {content_type}\"\n                # Check for xlsx file signature: first 2 bytes should be 'PK' (ZIP file signature)\n                assert content[:2] == b'PK', f\"Excel export does not appear to be a valid XLSX file for {fmt}\"\n            elif fmt == \"pdf\":\n                assert \"application/pdf\" in content_type.lower(), f\"Expected pdf content-type for {fmt}, got {content_type}\"\n                # PDF files start with %PDF\n                assert content[:4] == b'%PDF', f\"PDF export does not start with %PDF header for {fmt}\"\n            else:\n                assert False, f\"Unknown format tested: {fmt}\"\n\n        except (requests.RequestException, AssertionError) as e:\n            raise AssertionError(f\"Test failed for export format '{fmt}': {e}\")\n\ntest_data_export_functionality()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 30, in test_data_export_functionality\nAssertionError: Failed format json: HTTP 404\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 59, in <module>\n  File \"<string>\", line 57, in test_data_export_functionality\nAssertionError: Test failed for export format 'json': Failed format json: HTTP 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.669Z",
    "modified": "2025-11-19T12:43:45.522Z"
  },
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "a7514545-54f1-4192-9d39-9c624f700d25",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC009-account deletion process",
    "description": "test secure account deletion endpoint requiring otp verification and ensuring complete user data cleanup after successful deletion.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5000\"\nUSERNAME = \"pedrocastro767@gmail.com\"\nPASSWORD = \"qActive4@#\"\nTIMEOUT = 30\n\ndef test_account_deletion_process():\n    session = requests.Session()\n    session.auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n\n    otp = None\n\n    try:\n        # Step 1: Request OTP for account deletion\n        otp_request_resp = session.post(f\"{BASE_URL}/account/deletion/request-otp\", json={}, headers=headers, timeout=TIMEOUT)\n        assert otp_request_resp.status_code == 200, f\"OTP request failed: {otp_request_resp.text}\"\n        otp_data = otp_request_resp.json()\n        assert \"otp_sent\" in otp_data and otp_data[\"otp_sent\"] is True, \"OTP not sent confirmation missing\"\n\n        # Retrieve OTP from test endpoint\n        otp_retrieve_resp = session.get(f\"{BASE_URL}/account/deletion/test-get-otp\", headers=headers, timeout=TIMEOUT)\n        if otp_retrieve_resp.status_code == 200:\n            otp = otp_retrieve_resp.json().get(\"otp\")\n        else:\n            otp = \"000000\"\n\n        assert otp is not None, \"Failed to retrieve OTP for account deletion\"\n\n        # Step 2: Verify otp and perform account deletion\n        deletion_payload = {\"otp\": otp}\n        delete_resp = session.post(f\"{BASE_URL}/account/delete\", json=deletion_payload, headers=headers, timeout=TIMEOUT)\n        assert delete_resp.status_code == 200, f\"Account deletion failed: {delete_resp.text}\"\n        delete_resp_json = delete_resp.json()\n        assert delete_resp_json.get(\"deleted\") is True, \"Account deletion confirmation missing or false\"\n\n        # Step 3: Verify user data cleanup by attempting to fetch user profile\n        profile_resp = session.get(f\"{BASE_URL}/user/profile\", headers=headers, timeout=TIMEOUT)\n        assert profile_resp.status_code in (401, 403, 404), f\"User data still accessible after deletion: {profile_resp.status_code}\"\n\n    finally:\n        pass\n\ntest_account_deletion_process()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 49, in <module>\n  File \"<string>\", line 22, in test_account_deletion_process\nAssertionError: OTP request failed: {\"success\":false,\"message\":\"Rota /account/deletion/request-otp n達o encontrada\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.675Z",
    "modified": "2025-11-19T12:43:57.825Z"
  },
  {
    "projectId": "5ac1ae00-83f1-4657-a128-0c1fc6abec4d",
    "testId": "2e5cb729-84b1-4e74-96e6-853a0754b648",
    "userId": "948824b8-0031-70cb-e186-5a30cf288627",
    "title": "TC010-subscription management endpoints",
    "description": "verify subscription plan selection, checkout process, and subscription management endpoints to ensure correct subscription handling and payment integration.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5000\"\nUSERNAME = \"pedrocastro767@gmail.com\"\nPASSWORD = \"qActive4@#\"\nTIMEOUT = 30\n\ndef test_subscription_management_endpoints():\n    auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n    }\n\n    created_subscription_id = None\n\n    try:\n        # 1. Retrieve available subscription plans\n        plans_resp = requests.get(f\"{BASE_URL}/subscriptions/plans\", auth=auth, headers=headers, timeout=TIMEOUT)\n        assert plans_resp.status_code == 200, f\"Expected 200, got {plans_resp.status_code}\"\n        plans_data = plans_resp.json()\n        assert isinstance(plans_data, list), \"Plans response should be a list\"\n        assert len(plans_data) > 0, \"There should be at least one subscription plan\"\n\n        # Select a premium plan (assuming a plan with a \"premium\" tier or first plan)\n        premium_plan = None\n        for plan in plans_data:\n            if 'premium' in plan.get('tier', '').lower():\n                premium_plan = plan\n                break\n        if not premium_plan:\n            premium_plan = plans_data[0]\n\n        plan_id = premium_plan.get('id')\n        assert plan_id is not None, \"Selected plan must have an 'id'\"\n\n        # 2. Checkout Process - Create subscription checkout session\n        checkout_payload = {\"planId\": plan_id, \"paymentMethod\": \"mock_payment_method\"}  # paymentMethod field named generically\n        checkout_resp = requests.post(f\"{BASE_URL}/subscriptions/checkout\", auth=auth, headers=headers, json=checkout_payload, timeout=TIMEOUT)\n        assert checkout_resp.status_code == 201 or checkout_resp.status_code == 200, f\"Expected 201 or 200, got {checkout_resp.status_code}\"\n        checkout_data = checkout_resp.json()\n        assert 'subscriptionId' in checkout_data or 'id' in checkout_data, \"Response must contain subscription identifier\"\n\n        created_subscription_id = checkout_data.get('subscriptionId') or checkout_data.get('id')\n        assert created_subscription_id is not None, \"Subscription ID must be present after checkout\"\n\n        # 3. Retrieve subscription details\n        detail_resp = requests.get(f\"{BASE_URL}/subscriptions/{created_subscription_id}\", auth=auth, headers=headers, timeout=TIMEOUT)\n        assert detail_resp.status_code == 200, f\"Expected 200, got {detail_resp.status_code}\"\n        detail_data = detail_resp.json()\n        assert detail_data.get('id') == created_subscription_id, \"Subscription ID mismatch\"\n        assert detail_data.get('planId') == plan_id, \"Plan ID mismatch in subscription detail\"\n\n        # 4. List user subscriptions and validate the new subscription is listed\n        list_resp = requests.get(f\"{BASE_URL}/subscriptions\", auth=auth, headers=headers, timeout=TIMEOUT)\n        assert list_resp.status_code == 200, f\"Expected 200, got {list_resp.status_code}\"\n        list_data = list_resp.json()\n        assert any(s.get('id') == created_subscription_id for s in list_data), \"Created subscription should be in subscription list\"\n\n        # 5. Update subscription (e.g., change plan to free or another if supported)\n        # Find a different plan if possible for update test\n        update_plan_id = None\n        for plan in plans_data:\n            if plan['id'] != plan_id:\n                update_plan_id = plan['id']\n                break\n        if update_plan_id:\n            update_payload = {\"planId\": update_plan_id}\n            update_resp = requests.put(f\"{BASE_URL}/subscriptions/{created_subscription_id}\", auth=auth, headers=headers, json=update_payload, timeout=TIMEOUT)\n            assert update_resp.status_code == 200, f\"Expected 200 on update, got {update_resp.status_code}\"\n            updated_data = update_resp.json()\n            assert updated_data.get('planId') == update_plan_id, \"Plan ID should be updated in subscription\"\n\n        # 6. Cancel subscription\n        cancel_resp = requests.delete(f\"{BASE_URL}/subscriptions/{created_subscription_id}\", auth=auth, headers=headers, timeout=TIMEOUT)\n        assert cancel_resp.status_code == 204 or cancel_resp.status_code == 200, f\"Expected 204 or 200 on delete, got {cancel_resp.status_code}\"\n\n        # Validate subscription no longer retrievable\n        deleted_resp = requests.get(f\"{BASE_URL}/subscriptions/{created_subscription_id}\", auth=auth, headers=headers, timeout=TIMEOUT)\n        assert deleted_resp.status_code == 404 or deleted_resp.status_code == 410, \"Deleted subscription should not be found\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_subscription_management_endpoints()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 86, in <module>\n  File \"<string>\", line 21, in test_subscription_management_endpoints\nAssertionError: Expected 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-19T12:42:17.680Z",
    "modified": "2025-11-19T12:43:39.259Z"
  }
]
